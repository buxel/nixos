#!/usr/bin/env bash
# This script was generated by bashly 1.0.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
nixos_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos - nixos-cli application\n"
    echo

  else
    printf "nixos - nixos-cli application\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  nixos COMMAND\n"
  printf "  nixos [COMMAND] --help | -h\n"
  printf "  nixos --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Generate bash completions\n" "completions"
  printf "  %s   Install configuration to Linode VPS\n" "linode     "
  printf "  %s   Download a file\n" "download   "
  printf "  %s   Upload a file\n" "upload     "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
nixos_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(cli completions)\"\n"
    echo

  else
    printf "nixos completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  nixos completions\n"
  printf "  nixos completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nixos_linode_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos linode - Install configuration to Linode VPS\n"
    echo

  else
    printf "nixos linode - Install configuration to Linode VPS\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  nixos linode\n"
  printf "  nixos linode --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nixos_download_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos download - Download a file\n"
    echo

  else
    printf "nixos download - Download a file\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "Usage:"
  printf "  nixos download SOURCE [TARGET] [OPTIONS]\n"
  printf "  nixos download --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Overwrite existing files\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE"
    printf "    URL to download from\n"
    echo

    # :argument.usage
    printf "  %s\n" "TARGET"
    printf "    Target filename (default: same as source)\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "DEFAULT_TARGET_LOCATION"
    printf "    Set the default location to download to\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  cli download example.com\n"
    printf "  cli download example.com ./output -f\n"
    echo

  fi
}

# :command.usage
nixos_upload_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos upload - Upload a file\n"
    echo

  else
    printf "nixos upload - Upload a file\n"
    echo

  fi

  printf "Alias: u\n"
  echo

  printf "%s\n" "Usage:"
  printf "  nixos upload SOURCE [OPTIONS]\n"
  printf "  nixos upload --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user, -u USER (required)"
    printf "    Username to use for logging in\n"
    echo

    # :flag.usage
    printf "  %s\n" "--password, -p PASSWORD"
    printf "    Password to use for logging in\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE"
    printf "    File to upload\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if ((${#args[@]})); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/choose.sh
# # https://github.com/the0neWhoKnocks/shell-menu-select
# CHAR__GREEN='\033[0;32m'
# CHAR__RED='\033[0;31m'
# CHAR__RESET='\033[0m'
# menuStr=""
# returnOrExit=""
#
# function __hideCursor {
#   printf "\033[?25l"
#

#   # capture CTRL+C so cursor can be reset
#   trap "__showCursor && echo '' && ${returnOrExit} 0" SIGINT
# }
#
# function __showCursor {
#   printf "\033[?25h"
#   trap - SIGINT
# }
#
# function __clearLastMenu {
#   local msgLineCount=$(printf "$menuStr" | wc -l)
#   # moves the cursor up N lines so the output overwrites it
#   echo -en "\033[${msgLineCount}A"
#
#   # clear to end of screen to ensure there's no text left behind from previous input
#   [ $1 ] && tput ed
# }
#
# function __renderMenu {
#   local start=0
#   local selector=""
#   local instruction="$1"
#   local selectedIndex=$2
#   local listLength=$itemsLength
#   local longest=0
#   local spaces=""
#   menuStr="\n $instruction\n"
#
#   # Get the longest item from the list so that we know how many spaces to add
#   # to ensure there's no overlap from longer items when a list is scrolling up or down.
#   for (( i=0; i<$itemsLength; i++ )); do
#     if (( ${#menuItems[i]} > longest )); then
#       longest=${#menuItems[i]}
#     fi
#   done
#   spaces=$(printf ' %.0s' $(eval "echo {1.."$(($longest))"}"))
#
#   if [ $3 -ne 0 ]; then
#     listLength=$3
#
#     if [ $selectedIndex -ge $listLength ]; then
#       start=$(($selectedIndex+1-$listLength))
#       listLength=$(($selectedIndex+1))
#     fi
#   fi
#
#   for (( i=$start; i<$listLength; i++ )); do
#     local currItem="${menuItems[i]}"
#     currItemLength=${#currItem}
#
#     if [[ $i = $selectedIndex ]]; then
#       currentSelection="${currItem}"
#       selector="${CHAR__GREEN}ᐅ${CHAR__RESET}"
#       currItem="${CHAR__GREEN}${currItem}${CHAR__RESET}"
#     else
#       selector=" "
#     fi
#
#     currItem="${spaces:0:0}${currItem}${spaces:currItemLength}"
#
#     menuStr="${menuStr}\n ${selector} ${currItem}"
#   done
#
#   menuStr="${menuStr}\n"
#
#   # whether or not to overwrite the previous menu output
#   [ $4 ] && __clearLastMenu
#
#   printf "${menuStr}"
# }
#
# function __renderHelp {
#   echo;
#   echo "Usage: choose [OPTION]..."
#   echo "Renders a keyboard navigable menu with a visual indicator of what's selected."
#   echo;
#   echo "  -h, --help               Displays this message"
#   echo "  -i, --index              The initially selected index for the options"
#   echo "  -m, --max                Limit how many options are displayed"
#   echo "  -o, --options            An Array of options for a user to choose from"
#   echo "  -q, --query              Question or statement presented to the user"
#   # echo "  -v, --selectionVariable  Variable the selected choice will be saved to. Defaults to the 'selectedChoice' variable."
#   echo;
#   echo "Example:"
#   echo "  foodOptions=(\"pizza\" \"burgers\" \"chinese\" \"sushi\" \"thai\" \"italian\" \"shit\")"
#   echo;
#   echo "  choose -q \"What do you feel like eating?\" -o foodOptions -i 6 -m 4 -v \"firstChoice\""
#   echo "  printf \"\\n First choice is '\${firstChoice}'\\n\""
#   echo;
#   echo "  choose -q \"Select another option in case the first isn't available\" -o foodOptions"
#   echo "  printf \"\\n Second choice is '\${selectedChoice}'\\n\""
#   echo;
# }
#
# function choose {
#   local KEY__ARROW_UP=$(echo -e "\033[A")
#   local KEY__ARROW_DOWN=$(echo -e "\033[B")
#   local KEY__ENTER=$(echo -e "\n")
#   local captureInput=true
#   local displayHelp=false
#   local maxViewable=0
#   local instruction="Select an item from the list:"
#   local selectedIndex=0
#

#   unset selectedChoice
#   # unset selectionVariable
#

#   if [[ "${PS1}" == "" ]]; then
#     # running via script
#     returnOrExit="exit"
#   else
#     # running via CLI
#     returnOrExit="return"
#   fi
#

#   if [[ "${BASH}" == "" ]]; then
#     printf "\n ${CHAR__RED}[ERROR] This function utilizes Bash expansion, but your current shell is \"${SHELL}\"${CHAR__RESET}\n"
#     $returnOrExit 1
#   elif [[ $# == 0 ]]; then
#     printf "\n ${CHAR__RED}[ERROR] No arguments provided${CHAR__RESET}\n"
#     __renderHelp
#     $returnOrExit 1
#   fi
#

#   local remainingArgs=()
#   while [[ $# -gt 0 ]]; do
#     local key="$1"
#
#     case $key in
#       -h|--help)
#         displayHelp=true
#         shift
#         ;;
#       -i|--index)
#         selectedIndex=$2
#         shift 2
#         ;;
#       -m|--max)
#         maxViewable=$2
#         shift 2
#         ;;
#       -o|--options)
#         menuItems=$2[@]
#         menuItems=("${!menuItems}")
#         shift 2
#         ;;
#       -q|--query)
#         instruction="$2"
#         shift 2
#         ;;
#       # -v|--selectionVariable)
#       #   selectionVariable="$2"
#       #   shift 2
#       #   ;;
#       *)
#         remainingArgs+=("$1")
#         shift
#         ;;
#     esac
#   done
#
#   # just display help
#   if $displayHelp; then
#     __renderHelp
#     $returnOrExit 0
#   fi
#
#   set -- "${remainingArgs[@]}"
#   local itemsLength=${#menuItems[@]}
#

#   # no menu items, at least 1 required
#   if [[ $itemsLength -lt 1 ]]; then
#     printf "\n ${CHAR__RED}[ERROR] No menu items provided${CHAR__RESET}\n"
#     __renderHelp
#     $returnOrExit 1
#   fi
#
#   __renderMenu "$instruction" "$selectedIndex" "$maxViewable"
#   __hideCursor
#
#   while $captureInput; do
#     read -rsn3 key # `3` captures the escape (\033'), bracket ([), & type (A) characters.
#
#     case "$key" in
#       "$KEY__ARROW_UP")
#         selectedIndex=$((selectedIndex-1))
#         (( $selectedIndex < 0 )) && selectedIndex=$((itemsLength-1))
#
#         __renderMenu "$instruction" "$selectedIndex" "$maxViewable" true
#         ;;
#
#       "$KEY__ARROW_DOWN")
#         selectedIndex=$((selectedIndex+1))
#         (( $selectedIndex == $itemsLength )) && selectedIndex=0
#
#         __renderMenu "$instruction" "$selectedIndex" "$maxViewable" true
#         ;;
#
#       "$KEY__ENTER")
#         __clearLastMenu true
#         __showCursor
#         captureInput=false
#

#         # if [[ "${selectionVariable}" != "" ]]; then
#         #   printf -v "${selectionVariable}" "${currentSelection}"
#         # else
#           selectedChoice="${currentSelection}"
#         # fi
#         ;;
#     esac
#   done
#
#   export choice="$selectedChoice"
# }

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/menu.sh
#
#
# function print_menu()  # selected_item, ...menu_items
# {
# 	local function_arguments=($@)
#
# 	local selected_item="$1"
# 	local menu_items=(${function_arguments[@]:1})
# 	local menu_size="${#menu_items[@]}"
#
# 	for (( i = 0; i < $menu_size; ++i ))
# 	do
# 		if [ "$i" = "$selected_item" ]
# 		then
# 			echo "-> ${menu_items[i]}"
# 		else
# 			echo "   ${menu_items[i]}"
# 		fi
# 	done
# }
#
# function run_menu()  # selected_item, ...menu_items
# {
# 	local function_arguments=($@)
#
# 	local selected_item="$1"
# 	local menu_items=(${function_arguments[@]:1})
# 	local menu_size="${#menu_items[@]}"
# 	local menu_limit=$((menu_size - 1))
#
# 	clear
# 	print_menu "$selected_item" "${menu_items[@]}"
#

# 	while read -rsn1 input
# 	do
# 		case "$input"
# 		in
# 			$'\x1B')  # ESC ASCII code (https://dirask.com/posts/ASCII-Table-pJ3Y0j)
# 				read -rsn1 -t 0.1 input
# 				if [ "$input" = "[" ]  # occurs before arrow code
# 				then
# 					read -rsn1 -t 0.1 input
# 					case "$input"
# 					in
# 						A)  # Up Arrow
# 							if [ "$selected_item" -ge 1 ]
# 							then
# 								selected_item=$((selected_item - 1))
# 								clear
# 								print_menu "$selected_item" "${menu_items[@]}"
# 							fi
# 							;;
# 						B)  # Down Arrow
# 							if [ "$selected_item" -lt "$menu_limit" ]
# 							then
# 								selected_item=$((selected_item + 1))
# 								clear
# 								print_menu "$selected_item" "${menu_items[@]}"
# 							fi
# 							;;
# 					esac
# 				fi
# 				read -rsn5 -t 0.1  # flushing stdin
# 				;;
# 			"")  # Enter key
# 				return "$selected_item"
# 				;;
# 		esac
# 	done
# }
#
#
# # Usage example:
#
# selected_item=0
# menu_items=('Login' 'Register' 'Guest' 'Exit')
#
# run_menu "$selected_item" "${menu_items[@]}"
# menu_result="$?"
#
# echo
#
# case "$menu_result"
# in
# 	0)
# 		echo 'Login item selected'
# 		;;
# 	1)
# 		echo 'Register item selected'
# 		;;
# 	2)
# 		echo 'Guest item selected'
# 		;;
# 	3)
# 		echo 'Exit item selected'
# 		;;
# esac

# src/lib/send_completions.sh
send_completions() {
  echo $'# nixos completion                                         -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_nixos_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_nixos_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'download\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--force --help -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'linode\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upload\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help --password --user -h -p -u")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'l\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'d\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--force --help -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'u\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help --password --user -h -p -u")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help --version -h -v d download l linode u upload")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _nixos_completions nixos'
  echo $''
  echo $'# ex: filetype=sh'
}

# src/lib/shelpers.sh
info() {

  echo "$(green_bold "#") $(green $*)"

}

warn() {

  echo "$(red_bold "#") $(red $*)"

}

cmd() {

  local command execute
  case "$1" in
    "--dry-run" | "-d" )
      command="${@:2}"
      ;;
    *)

      command="${@}"
      execute="1"
      ;;
  esac
  echo "$(magenta_bold ">") $(magenta ${command//\%/%%})";
  [ -z "$execute" ] || $command > /tmp/cmd
}

url() {

  echo $1 | wl-copy; xdg-open $1
  echo "$(magenta_bold ">") $(cyan_underlined $1)"
}

ask() {

  local tone question answer
  case "$1" in
    "--warn" | "-w" )
      question="${@:2}"
      tone="warn"
      ;;
    "--info" | "-i" )
      question="${@:2}"
      ;;
    *)

      question="${@}"
      ;;
  esac

  if [[ "$answer" == "y" ]]; then

    return 0
  fi

  if [ "$tone" = "warn" ]; then
    echo -n "$(red_bold "#") $(red $*)"

  else
    echo -n "$(green_bold "#") $(green $*)"

  fi

  read -p " $(blue_bold y)/[$(red_bold n)] " -n 1 -r
  echo

  [[ $REPLY =~ ^[Yy]$ ]]

  if [ ! $? -ne 0 ]; then

    return 0
  else

    return 1
  fi
}

pause() {
  echo -n "$(green_bold "#") $(green "Press") $(blue_bold "y") $(green "to continue:") "

  local continue=""
  while [[ "$continue" != "y" ]]; do

    read -n 1 continue;

  done
  echo
}

# :command.command_functions
# :command.function
nixos_completions_command() {
  # src/completions_command.sh
  # Call the `send_completions` function which was added by running:
  #
  #   $ bashly add completions
  #
  # Users can now enable bash completion for this script by running:
  #
  #   $ eval "$(cli completions)"
  #
  send_completions

}

# :command.function
nixos_linode_command() {
  # src/linode_command.sh
  declare LINODE_ID

  function main {

    # Banner
    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃         Suderman's Linode Setup           ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    # Choose linode from list
    [ -z "$LINODE_ID" ] && LINODE_ID="$(choose_linode)"

    # Bail if no ID was selected
    if [ -z "$LINODE_ID" ]; then
      info "Exiting, no LINODE_ID provided"
      return 1
    fi

    # Look up details about this linode
    info "Gathering details..."
    local id="$LINODE_ID"

    local label="$(linode-cli linodes view $id --format label --no-header --text)"
    local linode_type=$(linode-cli linodes view $id --no-header --text --format type) # example: g6-standard-1
    local linode_size=$(linode-cli linodes type-view $linode_type --no-header --text --format disk) # example: 51200
    local installer_size=1024  # reserve 1GB for installer
    local nixos_size=$((linode_size - installer_size)) # nix uses remaining available disk
    local flags nixos_disk nixos_config installer_disk installer_config

    # Final warning
    warn "DANGER! Last chance to bail!"
    if ! ask --warn "Re-create all disks and configurations for linode $(yellow \"${label}\")?"; then
      return
    fi
    echo

    # Power down
    info "OK! Powering off linode. Please wait..."
    cmd linode-cli linodes shutdown $id
    wait_for_linode "offline"
    echo

    # Delete all configurations
    info "Deleting any existing configurations"
    configs=($(linode-cli linodes configs-list $id --text | awk 'NR > 1 {print $1}'))
    for config_id in "${configs[@]}"; do
      cmd linode-cli linodes config-delete $id $config_id
      sleep 5
    done
    echo

    # Delete all disks
    info "Deleting any existing disks"
    disks=($(linode-cli linodes disks-list $id --text | awk 'NR > 1 {print $1}'))
    for disk_id in "${disks[@]}"; do
      cmd linode-cli linodes disk-delete $id $disk_id
      while [ "$(linode-cli linodes disk-view $id $disk_id --text --no-header --format status 2>/dev/null)" == "deleting" ]; do
        sleep 5
      done
    done
    echo

    # Shared flags
    flags="--text --no-header"

    info "Creating INSTALLER disk"
    cmd linode-cli linodes disk-create $id $flags --label installer --filesystem ext4 --size $installer_size
    disk_id="$(cat /tmp/cmd | awk '{print $1}')"
    installer_disk="--devices.sdb.disk_id $disk_id"
    wait_for_disk $disk_id

    info "Creating NIXOS disk"
    cmd linode-cli linodes disk-create $id $flags --label nixos --filesystem raw --size $nixos_size
    disk_id="$(cat /tmp/cmd | awk '{print $1}')"
    nixos_disk="--devices.sda.disk_id $disk_id"
    wait_for_disk $disk_id

    # Shared flags
    flags="--text --no-header"
    flags="$flags --kernel linode/direct-disk"
    flags="$flags --helpers.updatedb_disabled=0 --helpers.distro=0 --helpers.modules_dep=0 --helpers.network=0 --helpers.devtmpfs_automount=0"

    # Create the installer configuration
    info "Creating INSTALLER configuration"
    cmd linode-cli linodes config-create $LINODE_ID $flags $nixos_disk $installer_disk --label installer --kernel linode/direct-disk --root_device /dev/sdb
    installer_config="--config_id $(cat /tmp/cmd | awk '{print $1}')"
    sleep 10
    echo

    # Create the main configuration
    info "Creating NIXOS configuration"
    cmd linode-cli linodes config-create $LINODE_ID $flags $nixos_disk --label nixos --root_device /dev/sda
    nixos_config="--config_id $(cat /tmp/cmd | awk '{print $1}')"
    sleep 10
    echo

    # Rescue mode
    info "Rebooting the linode in RESCUE mode"
    cmd linode-cli linodes rescue $id $installer_disk
    sleep 5
    wait_for_linode "running"
    echo

    # Create INSTALLER disk
    info "Opening a Weblish console:"
    url "https://cloud.linode.com/linodes/$id/lish/weblish"
    echo
    info "Paste the following to download the NixOS installer (copied to clipboard):"
    line1="iso=https://channels.nixos.org/nixos-22.11/latest-nixos-minimal-x86_64-linux.iso"
    line2="curl -L \$iso | tee >(dd of=/dev/sdb) | sha256sum"
    out $line1
    out $line2
    echo "$line1; $line2" | wl-copy
    echo
    info "Wait until it's finished before we reboot with the INSTALLER config"
    pause
    echo

    # Installer config
    info "Rebooting the linode..."
    cmd linode-cli linodes reboot $id $installer_config
    sleep 5
    wait_for_linode "running"
    echo

    info "Opening a Glish console:"
    url "https://cloud.linode.com/linodes/$id/lish/glish"
    echo
    info "Paste the following to install NixOS (second line copied to clipboard):"
    echo "sudo -s"
    echo "bash <(curl -sL https://github.com/suderman/nixos/raw/main/configurations/min/install.sh) LINODE" | tee >(wl-copy)
    echo

    info "Wait until it's finished before we reboot with NIXOS config"
    pause
    echo

    # NixOS config
    info "Rebooting the linode..."
    cmd linode-cli linodes reboot $id $nixos_config
    sleep 5
    wait_for_linode "running"
    echo

    # Update secrets keys
    info "Scanning new host key in 30 seconds..."
    sleep 30
    local ip="$(linode-cli linodes view $id --no-header --text --format ipv4)"
    cmd $dir/secrets/scripts/secrets-keyscan $ip $label --force
    echo
    info "Commit and push to git so changes can be pulled on the new linode at /etc/nixos"
    cmd "cd $dir && git status"
    cd $dir && git status
    sleep 5

    # Test login
    info "Opening a Weblish console:"
    url "https://cloud.linode.com/linodes/$id/lish/weblish"
    echo
    info "Login as user, pull from git, and rebuild config (copied to clipboard):"
    line1="cd /etc/nixos; git pull"
    line2="sudo nixos-rebuild switch"
    cmd "$line1"
    cmd "$line2"
    echo "$line1; $line2" | wl-copy
    echo

    # After switching to intended configuration, clean the changes made to min
    # cd /etc/nixos; git restore configurations/min

    # #
    # echo "LINODE_ID:"
    # msg "$LINODE_ID"
    # # # url "$LINODE_ID"
    # url https://suderman.net
    # cmd -d "$LINODE_ID"
    # pwd
    # cmd -d lsblk -f
    # cmd pwd
    # pause
    #
    # if ask "Really do it?"; then
    #   cmt "we are doing it"
    # fi

  }

  function choose_linode {
    local linodes="$(linode-cli linodes list --text --no-header | awk '{print $1"_"$2}')"
    local linode="$(echo $linodes | tr " " "\n" | fzf \
      --border-label=" Choose which existing linode to prepare " \
      --border \
      --height=40% \
      --margin=1 \
      --padding=1 \
      --layout=reverse \
      --info=hidden)"
    echo "${linode%_*}"
  }

  function wait_for_linode {
    printf "   "
    while [ "$(linode-cli linodes view $LINODE_ID --text --no-header --format status)" != "$1" ]; do
      echo -n $(yellow ".")
      sleep 5
    done
    echo
  }

  function wait_for_disk {
    while [ "$(linode-cli linodes disk-view $LINODE_ID $1 --text --no-header --format status 2>/dev/null)" != "ready" ]; do
      sleep 5
    done
    echo
  }

  main

}

# :command.function
nixos_download_command() {
  # src/download_command.sh
  echo "# this file is located in 'src/download_command.sh'"
  echo "# code for 'cli download' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  echo "before $(red this is red) after"
  echo "before $(green_bold this is green_bold) after"

}

# :command.function
nixos_upload_command() {
  # src/upload_command.sh
  echo "# this file is located in 'src/upload_command.sh'"
  echo "# code for 'cli upload' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        nixos_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    completions)
      action="completions"
      shift
      nixos_completions_parse_requirements "$@"
      shift $#
      ;;

    linode | l)
      action="linode"
      shift
      nixos_linode_parse_requirements "$@"
      shift $#
      ;;

    download | d)
      action="download"
      shift
      nixos_download_parse_requirements "$@"
      shift $#
      ;;

    upload | u)
      action="upload"
      shift
      nixos_upload_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      nixos_usage >&2
      exit 1
      ;;

    *)
      if [[ -x "$(command -v "nixos-$action")" ]]; then
        shift
        exec "nixos-$action" "$@"
      else
        printf "invalid command: %s\n" "$action" >&2
        exit 1
      fi
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_linode_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_linode_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="linode"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_download_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_download_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="download"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['source']+x} ]]; then

          args['source']=$1
          shift
        elif [[ -z ${args['target']+x} ]]; then

          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: nixos download SOURCE [TARGET] [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
nixos_upload_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_upload_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="upload"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user, -u USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --password | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--password']="$2"
          shift
          shift
        else
          printf "%s\n" "--password requires an argument: --password, -p PASSWORD" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['source']+x} ]]; then

          args['source']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: nixos upload SOURCE [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.required_flags_filter
  if [[ -z ${args['--user']+x} ]]; then
    printf "missing required flag: --user, -u USER\n" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "completions")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_completions_usage
      else
        nixos_completions_command
      fi
      ;;

    "linode")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_linode_usage
      else
        nixos_linode_command
      fi
      ;;

    "download")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_download_usage
      else
        nixos_download_command
      fi
      ;;

    "upload")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_upload_usage
      else
        nixos_upload_command
      fi
      ;;

  esac
}

initialize
run "$@"
