#!/usr/bin/env bash
# This script was generated by bashly 1.0.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
nixos_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos - nixos-cli application\n"
    echo

  else
    printf "nixos - nixos-cli application\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos COMMAND\n"
  printf "  nixos [COMMAND] --help | -h\n"
  printf "  nixos --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Wizard up a NixOS installation\n" "$(green "wizard")         "
  printf "  %s   Shortcut for nixos-rebuild switch\n" "$(green "switch")         "
  printf "  %s   Install configuration to Linode VPS\n" "$(green "linode")         "
  printf "  %s   Bootstrap a NixOS installation\n" "$(green "bootstrap")      "
  echo
  printf "%s\n" "$(bold "Secrets Commands:")"
  printf "  %s   Edit or add secrets to secrets/files\n" "$(green "secrets")        "
  printf "  %s   Rekey secrets with secrets/keys\n" "$(green "rekey")          "
  printf "  %s   Scan a host for public keys and add to secrets/keys\n" "$(green "keyscan")        "
  echo
  printf "%s\n" "$(bold "Utility Commands:")"
  printf "  %s   Shortcut for bashly generate\n" "$(green "bashly-generate")"
  printf "  %s   Generate bash completions\n" "$(green "completions")    "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(magenta "--version, -v")"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
nixos_wizard_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos wizard - Wizard up a NixOS installation\n"
    echo

  else
    printf "nixos wizard - Wizard up a NixOS installation\n"
    echo

  fi

  printf "Alias: w\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos wizard [TYPE] [OPTIONS]\n"
  printf "  nixos wizard --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--swap, -s SWAP")"
    printf "    min, max, or any number of GB for swap (default: max)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TYPE")"
    printf "    uefi, bios, linode\n"
    echo

  fi
}

# :command.usage
nixos_switch_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos switch - Shortcut for nixos-rebuild switch\n"
    echo

  else
    printf "nixos switch - Shortcut for nixos-rebuild switch\n"
    echo

  fi

  printf "Alias: sw\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos switch\n"
  printf "  nixos switch --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nixos_secrets_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos secrets\n"
    echo

    printf "  Edit or add secrets to secrets/files\n  Wrapper for agenix --edit\n"
    echo

  else
    printf "nixos secrets - Edit or add secrets to secrets/files\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos secrets [SECRET] [OPTIONS]\n"
  printf "  nixos secrets --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--commit, -c")"
    printf "    Automatically commit changes to git\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "SECRET")"
    printf "    name of secret (leave empty to choose from list)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nixos secrets\n"
    printf "  nixos secrets foo\n"
    echo

  fi
}

# :command.usage
nixos_rekey_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos rekey\n"
    echo

    printf "  Rekey secrets with secrets/keys\n  Wrapper for agenix --rekey\n"
    echo

  else
    printf "nixos rekey - Rekey secrets with secrets/keys\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos rekey [OPTIONS]\n"
  printf "  nixos rekey --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--force, -f")"
    printf "    Force rekey even if no changes have been detected\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--commit, -c")"
    printf "    Automatically commit changes to git\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nixos rekey\n"
    printf "  nixos rekey --force\n"
    printf "  nixos rekey --commit\n"
    echo

  fi
}

# :command.usage
nixos_keyscan_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos keyscan\n"
    echo

    printf "  Scan a host for public keys and add to secrets/keys\n  Wrapper for ssh-keyscan\n"
    echo

  else
    printf "nixos keyscan - Scan a host for public keys and add to secrets/keys\n"
    echo

  fi

  printf "Alias: k\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos keyscan IP [HOSTNAME] [OPTIONS]\n"
  printf "  nixos keyscan --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--force, -f")"
    printf "    Force rekey after keyscan\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--add, -a")"
    printf "    Add extra host key instead of replacing\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--commit, -c")"
    printf "    Automatically commit changes to git\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IP")"
    printf "    IP address or hostname\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "HOSTNAME")"
    printf "    Name of host (default: first argument)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nixos keyscan 192.168.1.10 myhost\n"
    printf "  nixos keyscan 192.168.1.10 myhost --force\n"
    printf "  nixos keyscan 192.168.1.10 myhost --add --commit\n"
    echo

  fi
}

# :command.usage
nixos_linode_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos linode - Install configuration to Linode VPS\n"
    echo

  else
    printf "nixos linode - Install configuration to Linode VPS\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos linode\n"
  printf "  nixos linode --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nixos_bootstrap_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos bootstrap - Bootstrap a NixOS installation\n"
    echo

  else
    printf "nixos bootstrap - Bootstrap a NixOS installation\n"
    echo

  fi

  printf "Alias: b\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos bootstrap TYPE [CONFIGURATION] [OPTIONS]\n"
  printf "  nixos bootstrap --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--swap, -s SWAP")"
    printf "    min, max, or any number of GB for swap (default: max)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TYPE")"
    printf "    uefi, bios, linode\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "CONFIGURATION")"
    printf "    Name of configuration\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nixos bootstrap linode\n"
    printf "  nixos bootstrap uefi --swap min\n"
    printf "  nixos bootstrap bios --swap 8\n"
    printf "  nixos bootstrap switch sol\n"
    echo

  fi
}

# :command.usage
nixos_bashly_generate_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos bashly-generate - Shortcut for bashly generate\n"
    echo

  else
    printf "nixos bashly-generate - Shortcut for bashly generate\n"
    echo

  fi

  printf "Alias: bg\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos bashly-generate\n"
  printf "  nixos bashly-generate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nixos_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(cli completions)\"\n"
    echo

  else
    printf "nixos completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos completions\n"
  printf "  nixos completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if ((${#args[@]})); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/helpers.sh
#!/usr/bin/env bash

# True if command or file does exist
function has {
  if [[ -e "$1" ]]; then return 0; fi
  command -v "$1" >/dev/null 2>&1 && { return 0; }
  return 1
}

# True if command or file doesn't exist
function hasnt {
  if [[ -e "$1" ]]; then return 1; fi
  command -v "$1" >/dev/null 2>&1 && { return 1; }
  return 0
}

# Install nixos dependencies if they don't exist
# If package name doesn't match command, append pkg after colon
# Example: dependencies git awk:gawk smenu
function dependencies {
  local arg cmd pkg
  for arg in "$@"; do
    if [[ $arg == *":"* ]]; then
      IFS=: read -r cmd pkg <<< "$arg"
    else
      cmd="$arg"
      pkg="$arg"
    fi
    if hasnt $cmd; then
      info "Installing $pkg"
      task nix-env -iA nixos.$pkg
    fi
  done
}

# Dependencies used by this helper script
dependencies lsblk:util-linux smenu

# True if variable is not empty
function defined {
  if [[ -z "$1" ]]; then return 1; fi

  return 0
}

# True if variable is empty
function empty {
  if [[ -z "$1" ]]; then return 0; fi
  return 1
}

# Echo information
function info {

  echo "$(green_bold "#") $(green "$*")"

}

# Echo warning
function warn {

  echo "$(red_bold "#") $(red "$*")"

}

# Return error
function error {

  warn "Error: ${*-exiting}" && exit 1
}

# Show arguments
function show {
  echo "$(magenta_bold ">") $(magenta "$*")";
}

# Echo task and execute command (unless --dry-run)
# function task {

#   local cmd="$(strip_flags "${@}")"
#   show "$cmd"
#   is_dry "${@}" || eval "$cmd" > /tmp/task
# }
function task {

  show "${@}"
  eval "${@}" > /tmp/task
}

# Echo output from last task
function last {
  touch /tmp/task
  cat /tmp/task
}

# Echo URL, copy to clipboard, and open in browser
function url {

  has wl-copy && echo "$1" | wl-copy
  has xdg-open && xdg-open "$1"
  echo "$(magenta_bold ">") $(cyan_underlined "$1")"
}

# Pause script until input
function pause {
  info "${1-Paused}"
  smenu -d -i "continue" -a e:7 i:2,br c:2,blr <<< "Press enter to continue ..."
}

# function is_warn {
#   [[ "$1" == "--warn" || "$1" == "-w" ]] && return 0
#   return 1
# }

# function is_dry {
#   [[ "$1" == "--dry-run" || "$1" == "-d" ]] && return 0
#   return 1
# }

# function strip_flags {
#   case "$1" in
#     "--warn" | "-w" | "--info" | "-i" | "--dry-run" | "-d") echo "${*:2}" ;;
#     * ) echo "${*}" ;;
#   esac
# }

# Echo but spaces replaced with newlines
function explode {
  echo "$@" | tr ' ' '\n'
}

# warn "Wanna go on?"
# if confirm; then
#   echo "You do! :)"
# else
#   echo "You don't :("
# fi
function confirm {
  [[ "$(ask "yes no")" == "yes" ]] && return 0 || return 1

}

# info "What is your name?"
# name="$(ask)"
# info "Which color?"
# color="$(ask "red green blue" "green")"
function ask {

  # Check for 1st arg or stdin
  local words="${1}"; [[ -p /dev/stdin ]] && words="$(cat -)"
  # Check for 2nd arg as search word
  local search="${2}"; [[ -n "$search" ]] && search="-s ${search}"

  # If any words, get choice from smenu
  if [[ -n "$words" ]]; then
    smenu -c -a i:3,b c:3,br $search <<< "$words"
  # Otherwise, prompt for input
  else
    local reply=""; while [[ -z "$reply" ]]; do
      read -p "$(blue_bold :) " -e reply
    done; echo "$reply"
  fi
}

# info "Choose your disk"
# disk="$(ask_disk)"
function ask_disk {
  # prepare menu of disks
  local menu="$(lsblk -o NAME,FSTYPE,LABEL,FSAVAIL,FSUSE%,MOUNTPOINT)"
  menu="${menu}\n__\n"
  menu="${menu}refresh__ cancel__"
  # choose disk from menu
  local disk="refresh"
  while [[ "$disk" = "refresh" ]]; do
    disk="$(smenu -c -q -n 20 -N -d \
      -I '/__/ /g' -E '/__/ /g' \
      -i ^nvme -i ^sd -i ^hd -i ^vd \
      -i refresh -i cancel \
      -a e:4 i:6,b c:6,br  \
      -1 '(refresh|cancel)' '3,b' \
      -s /refresh \
      <<< "$menu")"
  done
  [[ "$disk" != "cancel" ]] && echo "$disk" || return 1
}

# smenu formatting
# ----------------
#
# [fb]/[bg],[blru]
#
# 0: black    1: red    2: green
# 3: yellow   4: blue   5: purple
# 6: aqua     7: white  8: gray
#

# [b]old b[l]inking [r]everse [u]nderline
#
# -N                   :: numbers added for selection
# -q                   :: hide scroll bar
# -N                   :: numbers added for selection
# -n 20                :: number of lines height
# -i '^[a-z].'         :: regex for what is selectable
# -1 '^[a-z].' '1/0,b' :: regex for formatting
# -m                   :: Message for title
# -d                   :: Clear menu after selection
# -W$'\n'              ::

# src/lib/send_completions.sh
send_completions() {
  echo $'# nixos completion                                         -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_nixos_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_nixos_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'download\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--force --help -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'linode\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upload\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help --password --user -h -p -u")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'l\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'d\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--force --help -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'u\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help --password --user -h -p -u")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help --version -h -v d download l linode u upload")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _nixos_completions nixos'
  echo $''
  echo $'# ex: filetype=sh'
}

# :command.command_functions
# :command.function
nixos_wizard_command() {
  # src/wizard_command.sh
  echo "# this file is located in 'src/wizard_command.sh'"
  echo "# code for 'nixos wizard' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  dependencies git tig awk:gawk lazydocker smenu

  warn "Wanna go on?"
  if confirm; then
    echo "You do! :)"
  else
    echo "You don't :("
  fi

  info "Be cool"
  ask
  ask one two three

  info "Choose your disk"
  disk="$(ask_disk)"
  show $disk

  task "ls -lah && pwd"
  info "Cool!"

  info "What's it gonna be?"
  val=$(ask ready set go)
  show $val

  info "What is your name?"
  name="$(ask)"
  show $name

  pause

  pause "Again people"

  if confirm --warn Scary?; then
    echo "You think scary"
  else
    echo "You dunna want it"
  fi

  ask "one" "two" "three"

  warn "Well? What it gunna be?"
  if confirm; then
    show you agreed
  else
    show you did not agree
  fi

  pause "Hold it!"

  # Wait until live and then keyscan
  # until ping -c1 $ip_address >/dev/null 2>&1; do
  #   sleep 5
  # done
  # nixos keyscan $ip_address $config_name

}

# :command.function
nixos_switch_command() {
  # src/switch_command.sh
  show 'nixos-rebuild switch --flake /etc/nixos#'$(hostname)
  sudo nixos-rebuild switch --flake /etc/nixos#$(hostname)

}

# :command.function
nixos_secrets_command() {
  # src/secrets_command.sh
  dependencies awk:gawk git sed:gnused
  local dir="/etc/nixos/secrets" secret

  function main {

    # Get args and ensure agenix
    secret="${args[secret]}"
    has agenix || error "agenix missing"

    # Choose secret with menu
    secret="$(ask "[new] $(list_secrets)" $secret)"

    # If [new], ask for name of new secret
    if [[ "$secret" == "[new]" ]]; then
      secret="$(ask)"
    fi

    # Add (or use existing) secret by argument name
    has_secret "$secret" || add_secret "$secret"

    # Edit secret with agenix
    info "Editing secret with agenix"
    show "cd $dir && agenix --edit \"files/$secret.age\""
    cd $dir && agenix --edit "files/$secret.age"

    # Update files/default.nix
    write_files_nix

    # Commit secrets
    git_commit

  }

  # Write the default.nix file compiling all age files
  function write_files_nix {

    # Ouput file path

    local nix="$dir/files/default.nix"

    info "Writing $nix"

    # Build recursive attribute set
    echo "# Do not modify this file!  It was generated by ‘nixos secrets’ " > $nix
    echo "# and may be overwritten by future invocations. "                >> $nix
    echo "# Please add age files to $dir/files/*.age "                     >> $nix
    echo "{"                                                               >> $nix
    echo ""                                                                >> $nix

    # Read each encrypted age file
    for file in $dir/files/*.age; do

      # Derive the attribute key from the filename
      local name=$(basename "$file" ".age")

      # Write the attribute name and path to default.nix
      echo "  $name = ./${name}.age;" >> $nix

    done

    # Finish

    echo "" >> $nix
    echo "}" >> $nix

    show "echo \"{ ... }\" > $nix"

  }

  function list_secrets {
    local nix="$dir/secrets.nix"
    nix-instantiate --eval --expr "(import $nix)" | tr ";" "\n" | awk -F/ '{split($2, arr, "."); printf "%s ", arr[1]} END {print ""}'
  }

  function has_secret {
    [[ -z "$1" ]] && { return 1; }
    local nix="$dir/secrets.nix"
    local output="$(nix-instantiate --eval --expr "(import $nix).\"files/$1.age\"" 2>/dev/null)"
    [[ -z "$output" ]] && { return 1; }
    return 0
  }

  function add_secret {
    [[ -z "$1" ]] && { return 1; }
    local nix="$dir/secrets.nix"
    info "Appending $nix"
    task "sed -i '$ d' ${nix}"
    task "echo '  \"files/$1.age\".publicKeys = all;' >> $nix"
    task "echo '' >> $nix"
    task "echo '}' >> $nix"
  }

  function git_commit {
    info "Adding files to the staging area"
    task "cd $dir"\
         '&& git add ./secrets.nix ./files/*.age ./files/default.nix'
    if [[ "${args[--commit]}" == "1" ]]; then
      info "Committing staged files to the repository"
      task "cd $dir"\
           '&& git commit ./secrets.nix ./files/*.age ./files/default.nix'\
           "-m 'secret: $secret'"
    fi
  }

  main

}

# :command.function
nixos_rekey_command() {
  # src/rekey_command.sh
  dependencies awk:gawk git sed:gnused
  local dir="/etc/nixos/secrets"

  function main {

    # Ensure agenix
    has agenix || error "agenix missing"

    # Update keys/default.nix
    write_keys_nix

    # Rekey secrets with agenix and restage on git
    if [[ "$(prev_hash)" != "$(calc_hash)" ]] || [[ "${args[--force]}" == "1" ]]; then
      agenix_rekey && update_hash && git_commit
    else
      info "No changes detected"
    fi

  }

  # Write the default.nix file compiling all public keys
  function write_keys_nix {

    # Ouput file path

    local nix="$dir/keys/default.nix"

    # List of all key names
    local users=""
    local systems=""

    info "Writing $nix"

    # Build recursive attribute set
    echo "$(prev_hash)" > $nix
    echo "# Do not modify this file!  It was generated by ‘nixos rekey’ "  >> $nix
    echo "# and may be overwritten by future invocations. "                >> $nix
    echo "# Please add public keys to $dir/keys/*.pub "                    >> $nix
    echo "rec {"                                                           >> $nix
    echo ""                                                                >> $nix

    # Read each @*.pub file (users) in the directory
    for file in $dir/keys/@*.pub; do

      # Derive the attribute key from the filename
      local key=$(basename "$file" ".pub")
      key="${key#@}" # remove @ from start

      # Write the attribute key and value to default.nix
      echo "  users.$key = \"$(cat "$file")\";" >> $nix

      # Collect list of key names
      users=$(echo " $users users.$key " | xargs)

    done

    # Finish with users, containing list of key names
    echo "  users.all = [ $users ];" >> $nix

    echo "" >> $nix

    # Read each *.pub file in the directory
    for file in $dir/keys/*.pub; do

      [[ "$file" =~ ^$dir/keys/@.* ]] && continue

      # Derive the attribute key from the filename
      local key=$(basename "$file" ".pub")

      # Write the attribute key and value to default.nix
      echo "  systems.$key = \"$(cat "$file")\";" >> $nix

      # Collect list of key names
      systems=$(echo " $systems systems.$key " | xargs)

    done

    # Finish with systems, containing list of key names
    echo "  systems.all = [ $systems ];" >> $nix

    echo "" >> $nix

    # Finish with all, containing list of key names
    echo "  all = users.all ++ systems.all;" >> $nix

    echo ""  >> $nix
    echo "}" >> $nix

    show "echo \"rec { ... }\" > $nix"

  }

  function prev_hash {
    head -n1 $dir/keys/default.nix
  }

  function calc_hash {
    echo "# $(ls -lah $dir/keys/*.pub | md5sum | awk '{print $1}')"
  }

  function update_hash {
    local file="$dir/keys/default.nix"
    local hash="$(calc_hash)"
    sed -i "1s/.*/$hash/" $file
  }

  # Rekey secrets with agenix
  function agenix_rekey {

    # Rekey and add any new secrets
    info "Rekeying secrets with agenix"

    show "cd $dir/secrets && agenix --rekey"
    cd $dir && agenix --rekey && return 0
    return 1

  }

  function git_commit {
    info "Adding files to the staging area"
    task "cd $dir"\
         '&& git add ./keys ./files/*.age'
    if [[ "${args[--commit]}" == "1" ]]; then
      info "Committing staged files to the repository"
      task "cd $dir"\
           '&& git commit ./keys ./files/*.age -m rekey'
    fi
  }

  main

}

# :command.function
nixos_keyscan_command() {
  # src/keyscan_command.sh
  dependencies awk:gawk ssh-keyscan:openssh
  local dir="/etc/nixos/secrets" ip hostname

  function main {

    # Ensure ssh-keyscan
    has ssh-keyscan || error "ssh-keyscan missing"

    # Set up args
    ip="${args[ip]}" hostname="$(hostname)"

    # Attempt to scan public key
    task ssh-keyscan -t ssh-ed25519 $ip 2> /dev/null
    local key="$(last | awk '{print $2} {print $3}' | xargs)"
    local filename="$(filename)"

    # Check for acquired key
    show "key=\"$key\""
    if [[ -z "$key" ]]; then
      error "failed to scan key from $ip"
    fi

    # Add extra key
    if [[ "${args[--add]}" == "1" ]]; then
      filename="$(filename unique)"

    # Replace existing key
    else
      # Delete any existing keys if forced
      if [[ "${args[--force]}" == "1" ]]; then
        remove "$filename"
      # Otherwise, first check if key exists
      else
        if [[ -e "$filename" ]]; then
          # Ask before deleting existing key
          info "Key \"$hostname\" already exists, replace?"

          if confirm; then
            remove "$filename"
          # Exit with error
          else
            error "Key \"$hostname\" already exists"
          fi
        fi
      fi
    fi

    # Write key to file
    info "Writing $filename"
    show 'echo "${key}" > '"$filename"
    echo "${key}" > $filename

    # Rekey the secrets with the new identity
    if [[ "${args[--commit]}" == "1" ]]; then
      nixos rekey --commit
    else
      nixos rekey
    fi

  }

  # Modify hostname to ensure

  # - it doesn't end in .pub
  # - periods replaces with hypens
  # - only alphanumeric with hypens and underscores
  # - no leading/trailing hypens and underscores
  # - if it starts with a number (IP address), prepend with underscore
  function hostname {
    local hostname="${args[hostname]}"
    [[ -z "$hostname" ]] && hostname="${args[ip]}"
    echo "$(awk '{

      gsub(/\.pub$/, "", $0);

      gsub(/[\. -]+/, "-", $0);

      gsub(/[^a-zA-Z0-9_-]+/, "", $0);

      gsub(/^[-_]+|[-_]+$/, "", $0);

      if (substr($0, 1, 1) ~ /^[0-9]/) { $0 = "_" $0 };

      print tolower($0)

    }' <<< $hostname)"
  }

  function filename {
    local filename="${dir}/keys/${hostname}.pub"
    if [[ "$1" == "unique" ]]; then
      [[ -e $filename ]] && echo "${dir}/keys/${hostname}-$(date +%s).pub"
    else
      echo "$filename"
    fi
  }

  function remove {
    info "Removing $1"
    task "rm -f $1"
  }

  main

}

# :command.function
nixos_linode_command() {
  # src/linode_command.sh
  declare LINODE_ID

  function main {

    # Banner
    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃         Suderman's Linode Setup           ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    # Choose linode from list
    defined $LINODE_ID || LINODE_ID="$(choose_linode)"

    # Bail if no ID was selected
    if empty $LINODE_ID; then
      warn "Exiting, no LINODE_ID provided"
      return 1
    fi

    # Look up details about this linode
    info "Gathering details..."; echo
    local id="$LINODE_ID"

    local label="$(linode-cli linodes view $id --format label --no-header --text)"
    local linode_type=$(linode-cli linodes view $id --no-header --text --format type) # example: g6-standard-1
    local linode_size=$(linode-cli linodes type-view $linode_type --no-header --text --format disk) # example: 51200
    local installer_size=1024  # reserve 1GB for installer
    local nixos_size=$((linode_size - installer_size)) # nix uses remaining available disk
    local flags nixos_disk nixos_config installer_disk installer_config

    # Final warning
    warn "DANGER! Last chance to bail!"
    if ! ask --warn "Re-create all disks and configurations for linode $(yellow \"${label}\")?"; then
      return
    fi && echo

    # Power down
    info "OK! Powering off linode. Please wait..."
    task linode-cli linodes shutdown $id
    wait_for_linode "offline" && echo

    # Delete all configurations
    info "Deleting any existing configurations"
    configs=($(linode-cli linodes configs-list $id --text | awk 'NR > 1 {print $1}'))
    for config_id in "${configs[@]}"; do
      task linode-cli linodes config-delete $id $config_id
      sleep 5
    done && echo

    # Delete all disks
    info "Deleting any existing disks"
    disks=($(linode-cli linodes disks-list $id --text | awk 'NR > 1 {print $1}'))
    for disk_id in "${disks[@]}"; do
      task linode-cli linodes disk-delete $id $disk_id
      while [ "$(linode-cli linodes disk-view $id $disk_id --text --no-header --format status 2>/dev/null)" == "deleting" ]; do
        sleep 5
      done
    done && echo

    # Shared flags
    flags="--text --no-header"

    info "Creating INSTALLER disk"
    task linode-cli linodes disk-create $id $flags --label installer --filesystem ext4 --size $installer_size
    disk_id="$(cat /tmp/task | awk '{print $1}')"
    installer_disk="--devices.sdb.disk_id $disk_id"
    wait_for_disk $disk_id

    info "Creating NIXOS disk"
    task linode-cli linodes disk-create $id $flags --label nixos --filesystem raw --size $nixos_size
    disk_id="$(cat /tmp/task | awk '{print $1}')"
    nixos_disk="--devices.sda.disk_id $disk_id"
    wait_for_disk $disk_id

    # Shared flags
    flags="--text --no-header"
    flags="$flags --kernel linode/direct-disk"
    flags="$flags --helpers.updatedb_disabled=0 --helpers.distro=0 --helpers.modules_dep=0 --helpers.network=0 --helpers.devtmpfs_automount=0"

    # Create the installer configuration
    info "Creating INSTALLER configuration"
    task linode-cli linodes config-create $LINODE_ID $flags $nixos_disk $installer_disk --label installer --kernel linode/direct-disk --root_device /dev/sdb
    installer_config="--config_id $(cat /tmp/task | awk '{print $1}')"
    sleep 10 && echo

    # Create the main configuration
    info "Creating NIXOS configuration"
    task linode-cli linodes config-create $LINODE_ID $flags $nixos_disk --label nixos --root_device /dev/sda
    nixos_config="--config_id $(cat /tmp/task | awk '{print $1}')"
    sleep 10 && echo

    # Rescue mode
    info "Rebooting the linode in RESCUE mode"
    task linode-cli linodes rescue $id $installer_disk
    sleep 5
    wait_for_linode "running" && echo

    # Create INSTALLER disk
    info "Opening a Weblish console:"
    url "https://cloud.linode.com/linodes/$id/lish/weblish" && echo
    info "Paste the following to download the NixOS installer (copied to clipboard):"
    line1="iso=https://channels.nixos.org/nixos-22.11/latest-nixos-minimal-x86_64-linux.iso"
    line2="curl -L \$iso | tee >(dd of=/dev/sdb) | sha256sum"
    echo $line1
    echo $line2
    echo "$line1; $line2" | wl-copy && echo
    info "Wait until it's finished before we reboot with the INSTALLER config"
    pause && echo

    # Installer config
    info "Rebooting the linode..."
    task linode-cli linodes reboot $id $installer_config
    sleep 5
    wait_for_linode "running" && echo

    info "Opening a Glish console:"
    url "https://cloud.linode.com/linodes/$id/lish/glish" && echo
    info "Paste the following to install NixOS (second line copied to clipboard):"
    line1="sudo -s"
    line2="bash <(curl -sL https://github.com/suderman/nixos/raw/main/overlays/pkgs/nixos-cli/nixos) bootstrap linode"
    echo $line1
    echo $line2
    echo "$line2" | wl-copy && echo

    info "Wait until it's finished before we reboot with NIXOS config"
    pause && echo

    # NixOS config
    info "Rebooting the linode..."
    task linode-cli linodes reboot $id $nixos_config
    sleep 5
    wait_for_linode "running" && echo

    # Update secrets keys
    info "Scanning new host key in 30 seconds..."
    sleep 30
    local ip="$(linode-cli linodes view $id --no-header --text --format ipv4)"
    task "/etc/nixos/secrets/scripts/secrets-keyscan $ip $label --force"
    echo
    info "Commit and git push so changes can be pulled on the new linode at /etc/nixos"
    task "cd /etc/nixos && git status"

    sleep 5 && echo

    # Switch configuration
    info "Opening a Weblish console:"
    url "https://cloud.linode.com/linodes/$id/lish/weblish" && echo
    info "Login as root, pull from git, and rebuild config (copied to clipboard):"
    echo "nixos bootstrap switch [CONFIGURATION]"

    echo -n "nixos bootstrap switch " | wl-copy && echo

  }

  function choose_linode {
    local linodes="$(linode-cli linodes list --text --no-header | awk '{print $1"_"$2}')"
    local linode="$(explode $linodes | pick "Choose which existing linode to prepare")"
    echo "${linode%_*}"
  }

  function wait_for_linode {
    printf "  "
    while [ "$(linode-cli linodes view $LINODE_ID --text --no-header --format status)" != "$1" ]; do
      echo -n $(yellow ".")
      sleep 5
    done && echo
  }

  function wait_for_disk {
    while [ "$(linode-cli linodes disk-view $LINODE_ID $1 --text --no-header --format status 2>/dev/null)" != "ready" ]; do
      sleep 5
    done && echo
  }

  main

}

# :command.function
nixos_bootstrap_command() {
  # src/bootstrap_command.sh
  # sudo -s
  # bash <(curl -sL https://github.com/suderman/nixos/raw/main/overlays/pkgs/nixos-cli/nixos) bootstrap
  function main {

    if [ "$(id -u)" != "0" ]; then
      warn "Exiting, run as root."
      return 1
    fi

    # Be prepared
    install_dependencies

    # Switch configuration (stage 2)
    if is_switch; then

      switch_configuration
      return 0
    fi

    # Banner
    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃        Suderman's NixOS Installer         ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    # List disks and partitions for reference
    echo
    blue "Disks & Partitions                           "
    blue "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    lsblk -o NAME,FSTYPE,SIZE
    blue "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    # Choose a disk to partition
    local disk bbp esp swap butter
    is_linode && disk="sda" || disk="$(lsblk -nirdo NAME | pick "Choose the disk to partition")"

    # Bail if no disk selected
    if [ ! -e /dev/$disk ]; then
      warn "Exiting, no disk selected"
      return
    fi

    # Final warning
    warn "DANGER! This script will destroy any existing data on the \"$disk\" disk."
    if ! ask --warn "Proceed?"; then
      return
    fi

    warn "OK! Proceeding in 5 seconds..."
    sleep 5 && echo && echo

    info "Create GPT partition table"
    task parted -s /dev/$disk mklabel gpt
    echo

    # Booting with legacy BIOS requires BBP and ESP partitions
    if is_bios; then

      # /dev/sda1-4
      bbp="${disk}1"
      esp="${disk}2"
      swap="${disk}3"
      butter="${disk}4"

      info "Create BIOS boot partition ($bbp)"
      task parted -s /dev/$disk mkpart BBP 1MiB 3MiB
      task parted -s /dev/$disk set 1 bios_grub on
      echo

      info "Create EFI system partition ($esp)"
      task parted -s /dev/$disk mkpart ESP FAT32 3MiB 1GiB
      task parted -s /dev/$disk set 2 esp on
      echo

      info "Create swap partition ($swap)"
      task parted -s /dev/$disk mkpart swap linux-swap 1GiB $(swap_size)GiB
      task parted -s /dev/$disk set 3 swap on
      echo

    # Booting with UEFI, the ESP partition alone is fine
    else

      # /dev/sda1-3
      esp="${disk}1"
      swap="${disk}2"
      butter="${disk}3"

      info "Create EFI system partition ($esp)"
      task parted -s /dev/$disk mkpart ESP FAT32 1MiB 1GiB
      task parted -s /dev/$disk set 1 esp on
      echo

      info "Create swap partition ($swap)"
      task parted -s /dev/$disk mkpart swap linux-swap 1GiB $(swap_size)GiB
      task parted -s /dev/$disk set 2 swap on
      echo

    fi

    info "Create btrfs partition ($butter)"
    task parted -s /dev/$disk mkpart nix btrfs $(swap_size)GiB 100%
    echo

    info "Format EFI system partition"
    task mkfs.fat -F32 -n ESP /dev/$esp
    echo

    info "Enable swap partition"
    task mkswap /dev/$swap
    task swapon /dev/$swap
    echo

    info "Format btrfs partition"
    task mkfs.btrfs -fL nix /dev/$butter
    echo

    info "Create btrfs subvolume structure"
    # nix
    # ├── root
    # ├── snaps
    # └── state
    #     ├── home
    #     ├── etc
    #     └── var
    #         └── log
    task mkdir -p /mnt && mount /dev/$butter /mnt
    task btrfs subvolume create /mnt/root
    task btrfs subvolume create /mnt/snaps
    task btrfs subvolume snapshot -r /mnt/root /mnt/snaps/root
    task btrfs subvolume create /mnt/state
    task btrfs subvolume create /mnt/state/home
    task mkdir -p /mnt/state/{var/lib,etc/{ssh,NetworkManager/system-connections}}
    task btrfs subvolume create /mnt/state/var/log
    task umount /mnt
    echo

    info "Mount root"
    task mount -o subvol=root /dev/$butter /mnt
    echo

    info "Mount nix"
    task "mkdir -p /mnt/nix && mount /dev/$butter /mnt/nix"
    echo

    info "Mount boot"
    task "mkdir -p /mnt/boot && mount /dev/$esp /mnt/boot"
    echo

    # Path to nixos flake and minimal configuration
    local nixos="/mnt/nix/state/etc/nixos"

    local min="$nixos/configurations/min"

    # Clone git repo into persistant directory
    info "Cloning nixos git repo"
    if [ -d $nixos ]; then
      task "cd $nixos && git pull"
    else
      task "git clone https://github.com/suderman/nixos $nixos"
    fi
    echo

    # Generate config and copy hardware-configuration.nix
    info "Generating hardware-configuration.nix"
    task nixos-generate-config --root /mnt --dir $min
    task cp -f $min/hardware-configuration.nix $nixos/
    echo

    # If linode install detected, set config.hardware.linode.enable = true;
    if is_linode; then
      info "Enabling linode in configuration.nix"
      task "sed -i 's/hardware\.linode\.enable = false;/hardware.linode.enable = true;/' $min/configuration.nix"
      echo
    fi

    # Personal user owns /etc/nixos

    info "Updating configuration permissions"
    task chown -R 1000:100 $nixos
    echo

    # Run nixos installer
    info "Installing NixOS in 5 seconds..."
    show "nixos-install --flake $nixos\#min --no-root-password"
    sleep 5
    nixos-install --flake $nixos\#min --no-root-password
    echo

    info "Install complete!"
    info "Reboot without installer media and login as root."

  }

  function install_dependencies {
    if hasnt git; then
      info "Installing git"
      task nix-env -iA nixos.git
    fi
    if hasnt fzf; then
      info "Installing fzf"
      task nix-env -iA nixos.fzf
    fi
  }

  # Pull in rekeyed secrets, copy hardware-configuration from min to host, and switch
  function switch_configuration {
    local host="${args[configuration]}"
    if has_configuration; then

      info "Pulling secrets"
      task "cd /etc/nixos; git pull" && echo

      info "Copying generated hardware-configuration to $host"
      task mv -f /etc/nixos/configurations/min/hardware-configuration.nix /etc/nixos/configurations/$host/hardware-configuration.nix
      task "cd /etc/nixos; git restore configurations/min" && echo

      info "Rebuilding system to $host"
      show "nixos-rebuild switch --flake /etc/nixos\#${args[configuration]}"
      nixos-rebuild switch --flake /etc/nixos\#${args[configuration]}

      info "Rebuild complete!"
      info "Reboot in 10 seconds. Login as user and commit the generated hardware-configuration.nix to git."
      sleep 10 && systemctl reboot
      return 0

    else
      warn "Exiting, missing configuration"
      return 1
    fi
  }

  function is_switch {
    [ "${args[type]}" = "switch" ] && return 0 || return 1
  }

  function has_configuration {
    [ "${args[configuration]}" != "" ] && return 0 || return 1
  }

  function is_linode {
    [ "${args[type]}" = "linode" ] && return 0 || return 1
  }

  function is_bios {
    if [ "${args[type]}" = "bios" ] || [ "${args[type]}" = "linode" ]; then
      return 0
    else

      return 1
    fi
  }

  # Total memory available in GB
  function mem_total {
    free -b | awk '/Mem/ { printf "%.0f\n", $2/1024/1024/1024 + 0.5 }'
  }

  # Total memory availble squared in GB
  function mem_squared {
    mem_total | awk '{printf("%d\n", sqrt($1)+0.5)}'
  }

  # Memory squared, minimal value 2
  function swap_min {
    local mem="$(mem_squared)"
    [ "$mem" -lt "2" ] && mem="2"
    echo $mem
  }

  # Total memory + memory squared, minimal value 2
  function swap_max {
    local mem="$(echo $(mem_total) $(mem_squared) | awk '{printf "%d", $1 + $2}')"
    [ "$mem" -lt "2" ] && mem="2"
    echo $mem
  }

  # Swap is set to second argument
  # - if min, swap is memory squared (at least 2)
  # - if max, swap is memory total + memory squared (at least 2)
  # - if empty, swap is min if linode, max otherwise
  # - if any other value, swap is set to that
  function swap_size {
    local swap="${args[--swap]}"
    if [ "$swap" = "min" ]; then
      swap="$(swap_min)"
    elif [ "$swap" = "max" ]; then
      swap="$(swap_max)"
    elif [ "$swap" = "" ]; then
      is_linode && swap="$(swap_min)" || swap="$(swap_max)"
    fi
    # Add 1 since this value will be used in parted and starts at the 1GB position
    echo $swap | awk '{printf "%d", $1 + 1}'
  }

  main

}

# :command.function
nixos_bashly_generate_command() {
  # src/bashly_generate_command.sh
  local dir=/etc/nixos/overlays/pkgs/nixos-cli
  local bashly="docker run --rm -it --user $(id -u):$(id -g) --volume $dir:/app dannyben/bashly"
  task -d "cd $dir && bashly generate"
  (cd $dir && $bashly generate)

}

# :command.function
nixos_completions_command() {
  # src/completions_command.sh
  # Call the `send_completions` function which was added by running:
  #
  #   $ bashly add completions
  #
  # Users can now enable bash completion for this script by running:
  #
  #   $ eval "$(cli completions)"
  #
  send_completions

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        nixos_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    wizard | w)
      action="wizard"
      shift
      nixos_wizard_parse_requirements "$@"
      shift $#
      ;;

    switch | sw)
      action="switch"
      shift
      nixos_switch_parse_requirements "$@"
      shift $#
      ;;

    secrets | s)
      action="secrets"
      shift
      nixos_secrets_parse_requirements "$@"
      shift $#
      ;;

    rekey | r)
      action="rekey"
      shift
      nixos_rekey_parse_requirements "$@"
      shift $#
      ;;

    keyscan | k)
      action="keyscan"
      shift
      nixos_keyscan_parse_requirements "$@"
      shift $#
      ;;

    linode | l)
      action="linode"
      shift
      nixos_linode_parse_requirements "$@"
      shift $#
      ;;

    bootstrap | b)
      action="bootstrap"
      shift
      nixos_bootstrap_parse_requirements "$@"
      shift $#
      ;;

    bashly-generate | bg)
      action="bashly-generate"
      shift
      nixos_bashly_generate_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      nixos_completions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      nixos_usage >&2
      exit 1
      ;;

    *)
      if [[ -x "$(command -v "nixos-$action")" ]]; then
        shift
        exec "nixos-$action" "$@"
      else
        printf "invalid command: %s\n" "$action" >&2
        exit 1
      fi
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_wizard_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_wizard_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="wizard"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --swap | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--swap']="$2"
          shift
          shift
        else
          printf "%s\n" "--swap requires an argument: --swap, -s SWAP" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['type']+x} ]]; then

          args['type']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_switch_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_switch_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="switch"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_secrets_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_secrets_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="secrets"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --commit | -c)

        # :flag.case_no_arg
        args['--commit']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['secret']+x} ]]; then

          args['secret']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_rekey_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_rekey_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rekey"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --commit | -c)

        # :flag.case_no_arg
        args['--commit']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_keyscan_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_keyscan_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="keyscan"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_no_arg
        args['--add']=1
        shift
        ;;

      # :flag.case
      --commit | -c)

        # :flag.case_no_arg
        args['--commit']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['ip']+x} ]]; then

          args['ip']=$1
          shift
        elif [[ -z ${args['hostname']+x} ]]; then

          args['hostname']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['ip']+x} ]]; then
    printf "missing required argument: IP\nusage: nixos keyscan IP [HOSTNAME] [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
nixos_linode_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_linode_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="linode"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_bootstrap_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_bootstrap_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bootstrap"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --swap | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--swap']="$2"
          shift
          shift
        else
          printf "%s\n" "--swap requires an argument: --swap, -s SWAP" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['type']+x} ]]; then

          args['type']=$1
          shift
        elif [[ -z ${args['configuration']+x} ]]; then

          args['configuration']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: nixos bootstrap TYPE [CONFIGURATION] [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
nixos_bashly_generate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_bashly_generate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bashly-generate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "wizard")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_wizard_usage
      else
        nixos_wizard_command
      fi
      ;;

    "switch")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_switch_usage
      else
        nixos_switch_command
      fi
      ;;

    "secrets")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_secrets_usage
      else
        nixos_secrets_command
      fi
      ;;

    "rekey")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_rekey_usage
      else
        nixos_rekey_command
      fi
      ;;

    "keyscan")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_keyscan_usage
      else
        nixos_keyscan_command
      fi
      ;;

    "linode")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_linode_usage
      else
        nixos_linode_command
      fi
      ;;

    "bootstrap")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_bootstrap_usage
      else
        nixos_bootstrap_command
      fi
      ;;

    "bashly-generate")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_bashly_generate_usage
      else
        nixos_bashly_generate_command
      fi
      ;;

    "completions")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        nixos_completions_usage
      else
        nixos_completions_command
      fi
      ;;

  esac
}

initialize
run "$@"
