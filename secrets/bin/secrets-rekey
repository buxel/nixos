#!/usr/bin/env bash

# This script's directory
bin="$(dirname $(readlink -f $0))"

# This repo's directory
dir="$(dirname $(readlink -f $bin/..))"

# Directory holding the keys
pub="$dir/secrets/pub" 

# Main function
function rekey {

  # Force agenix to rekey, even if no changes detected
  if [ "$1" == "-f" ] || [ "$1" == "--force" ]; then
    force=1
  else

    # If an argument passed, show usage and exit
    if [ ! -z "$1" ]; then
      echo "Usage: secrets-rekey [-f/--force]"
      return 1
    fi

  fi

  # Update pub/default.nix
  write_nix 

  # Rekey secrets with agenix and restage on git
  if [ "$(prev_hash)" != "$(calc_hash)" ] || [ "$force" == 1 ]; then
    agenix_rekey && update_hash && git_stage
  else
    msg "No changes detected"
  fi

}

# Write the default.nix file compiling all public keys
function write_nix {

  # Ouput file path 
  local nix="$pub/default.nix"

  # List of all key names
  local users=""
  local systems=""

  msg "Writing $nix"

  # Build recursive attribute set
  echo "$(prev_hash)" > $nix
  echo "# Do not modify this file!  It was generated by ‘secrets-rekey’ "  >> $nix
  echo "# and may be overwritten by future invocations. "                  >> $nix
  echo "# Please add public keys to $pub/*.pub "                          >> $nix
  echo "rec {"                                                             >> $nix
  echo ""                                                                  >> $nix

  # Read each @*.pub file (users) in the directory
  for file in $pub/@*.pub; do

    # Derive the attribute key from the filename
    key=$(basename "$file" ".pub")
    key="${key#@}" # remove @ from start

    # Write the attribute key and value to default.nix
    echo "  users.$key = \"$(cat "$file")\";" >> $nix

    # Collect list of key names
    users=$(echo " $users users.$key " | xargs)

  done

  # Finish with users, containing list of key names
  # cmd  "  users = [ $users ];"
  echo "  users.all = [ $users ];" >> $nix

  echo "" >> $nix

  # Read each *.pub file in the directory
  for file in $pub/*.pub; do 
    [[ "$file" =~ ^$pub/@.* ]] && continue

    # Derive the attribute key from the filename
    key=$(basename "$file" ".pub")

    # Write the attribute key and value to default.nix
    # cmd  "  $key = \"$(cat "$file")\";"
    echo "  systems.$key = \"$(cat "$file")\";" >> $nix

    # Collect list of key names
    systems=$(echo " $systems systems.$key " | xargs)

  done

  # Finish with systems, containing list of key names
  # cmd  "  systems = [ $systems ];"
  echo "  systems.all = [ $systems ];" >> $nix

  echo "" >> $nix

  # Finish with all, containing list of key names
  # cmd  "  all = users ++ systems;"
  echo "  all = users.all ++ systems.all;" >> $nix

  # cmd  "}"
  echo ""  >> $nix
  echo "}" >> $nix

  cmd "echo \"rec { ... }\" > $nix"

}

function prev_hash {
  head -n1 $pub/default.nix
}

function calc_hash {
  echo "# $(ls -lah $pub/*.pub | md5sum | awk '{print $1}')"
}

function update_hash {
  local file="$pub/default.nix"
  local hash="$(calc_hash)"
  sed -i "1s/.*/$hash/" $file
}

# Rekey secrets with agenix
function agenix_rekey {

  # Rekey and add any new secrets
  msg "Rekeying secrets with agenix"

  cmd "cd $dir/secrets && agenix --rekey"
  cd $dir/secrets && agenix --rekey && return 0
  return 1

}

function git_stage {
  cmd "cd $dir/secrets && git add ."
  cd $dir/secrets && git add .
}

# /end of rekey script
# ------------------------


# Helper functions:
# -----------------------

# Colors               Underline                       Background             Color Reset        
_black_='\e[0;30m';   _underline_black_='\e[4;30m';   _on_black_='\e[40m';   _reset_='\e[0m' 
_red_='\e[0;31m';     _underline_red_='\e[4;31m';     _on_red_='\e[41m';
_green_='\e[0;32m';   _underline_green_='\e[4;32m';   _on_green_='\e[42m';
_yellow_='\e[0;33m';  _underline_yellow_='\e[4;33m';  _on_yellow_='\e[43m';
_blue_='\e[0;34m';    _underline_blue_='\e[4;34m';    _on_blue_='\e[44m';
_purple_='\e[0;35m';  _underline_purple_='\e[4;35m';  _on_purple_='\e[45m';
_cyan_='\e[0;36m';    _underline_cyan_='\e[4;36m';    _on_cyan_='\e[46m';
_white_='\e[0;37m';   _underline_white_='\e[4;37m';   _on_white_='\e[47m';

# These can be overridden
export MSG_COLOR="$_white_"
export MSG_PROMPT="$_green_=> $_reset_"

# Pretty messages
msg() { printf "$MSG_PROMPT$MSG_COLOR$1$_reset_\n"; }
cmd() { printf "$_cyan_> $1$_reset_\n"; }

# Color functions
black()  { printf "$_black_$1$MSG_COLOR"; }
red()    { printf "$_red_$1$MSG_COLOR"; }
green()  { printf "$_green_$1$MSG_COLOR"; }
yellow() { printf "$_yellow_$1$MSG_COLOR"; }
blue()   { printf "$_blue_$1$MSG_COLOR"; }
purple() { printf "$_purple_$1$MSG_COLOR"; }
cyan()   { printf "$_cyan_$1$MSG_COLOR"; }
white()  { printf "$_white_$1$MSG_COLOR"; }

# If $answer is "y", then we don't bother with user input
ask() { 
  if [[ "$answer" == "y" ]]; then return 0; fi
  printf "$MSG_PROMPT$MSG_COLOR$1$_reset_";
  read -p " y/[n] " -n 1 -r
  echo
  [[ $REPLY =~ ^[Yy]$ ]]
  if [ ! $? -ne 0 ]; then return 0; else return 1; fi
}

# /end of helper functions
# ------------------------

# DO IT
# -----
rekey $@
