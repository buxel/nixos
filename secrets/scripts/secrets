#!/usr/bin/env bash

# This script's directory
scripts="$(dirname $(readlink -f $0))"

# encrypted files directory
files="$(dirname $scripts)/files"

# secrets directory
secrets="$(dirname $scripts)"


# Main function
function secrets {
  secret="$1"

  # Choose secret with menu
  if [ -z "$secret" ]; then
    choices=($(list_secrets))
    choose -q "Select a secret:" -o choices -m 5 -v "secret"

  # Add (or use existing) secret by argument name
  else
    has_secret $secret || add_secret $secret
  fi

  # Edit secret with agenix
  cd $secrets && agenix --edit "files/${secret}.age"

  # Update age/default.nix
  write_nix 

  # Stage on git
  git_stage

}

# Write the default.nix file compiling all age files
function write_nix {

  # Ouput file path 
  local nix="$files/default.nix"

  msg "Writing $nix"

  # Build recursive attribute set
  echo "# Do not modify this file!  It was generated by ‘secrets’ " > $nix
  echo "# and may be overwritten by future invocations. "          >> $nix
  echo "# Please add age files to $files/*.age "                   >> $nix
  echo "{"                                                         >> $nix
  echo ""                                                          >> $nix

  # Read each encrypted age file
  for file in $files/*.age; do

    # Derive the attribute key from the filename
    name=$(basename "$file" ".age")

    # Write the attribute name and path to default.nix
    echo "  $name = ./${name}.age;" >> $nix

  done

  # Finish 
  echo "" >> $nix
  echo "}" >> $nix

  cmd "echo \"{ ... }\" > $nix"

}

function list_secrets {
  local nix="$secrets/secrets.nix"
  nix-instantiate --eval --expr "(import $nix)" | tr ";" "\n" | awk -F/ '{split($2, arr, "."); printf "%s ", arr[1]} END {print ""}'
}

function has_secret {
  [ -z "$1" ] && { return 1; }
  local nix="$secrets/secrets.nix"
  local output="$(nix-instantiate --eval --expr "(import $nix).\"files/$1.age\"" 2>/dev/null)"
  [ -z "$output" ] && { return 1; }
  return 0
}

function add_secret {
  [ -z "$1" ] && { return 1; }

  local nix="$secrets/secrets.nix"

  cmd "sed -i '$ d' $nix"
  sed -i '$ d' $nix

  cmd "echo '\"files/$1.age\".publicKeys = keys.all;' >> $nix"
  echo "  \"files/$1.age\".publicKeys = keys.all;" >> $nix
  echo "" >> $nix
  echo "}" >> $nix
}

function git_stage {
  cmd "cd $secrets && git add ."
  cd $secrets && git add .
}

# /end of secrets-set
# ------------------------



# Helper functions:
# -----------------------

# Colors               Underline                       Background             Color Reset        
_black_='\e[0;30m';   _underline_black_='\e[4;30m';   _on_black_='\e[40m';   _reset_='\e[0m' 
_red_='\e[0;31m';     _underline_red_='\e[4;31m';     _on_red_='\e[41m';
_green_='\e[0;32m';   _underline_green_='\e[4;32m';   _on_green_='\e[42m';
_yellow_='\e[0;33m';  _underline_yellow_='\e[4;33m';  _on_yellow_='\e[43m';
_blue_='\e[0;34m';    _underline_blue_='\e[4;34m';    _on_blue_='\e[44m';
_purple_='\e[0;35m';  _underline_purple_='\e[4;35m';  _on_purple_='\e[45m';
_cyan_='\e[0;36m';    _underline_cyan_='\e[4;36m';    _on_cyan_='\e[46m';
_white_='\e[0;37m';   _underline_white_='\e[4;37m';   _on_white_='\e[47m';

# These can be overridden
export MSG_COLOR="$_white_"
export MSG_PROMPT="$_green_:: $_reset_"
export CMD_PROMPT="$_purple_ > $_reset_"
export CMD_COLOR="$_cyan_"
export URL_PROMPT="$_purple_ > $_reset_"
export URL_COLOR="$_underline_cyan_"

# Pretty messages
msg() { printf "$MSG_PROMPT$MSG_COLOR$(echo $@)$_reset_\n"; }
out() { printf "$MSG_COLOR$(echo $@)$_reset_\n"; }
cmd() { printf "$CMD_PROMPT$CMD_COLOR$(echo $@)$_reset_\n"; }
url() { echo $1 | wl-copy; xdg-open $1; printf "$URL_PROMPT$URL_COLOR$1$_reset_\n"; }
run() { cmd "$@"; $@>/tmp/run; }

# Color functions
black()  { printf "$_black_$1$MSG_COLOR"; }
red()    { printf "$_red_$1$MSG_COLOR"; }
green()  { printf "$_green_$1$MSG_COLOR"; }
yellow() { printf "$_yellow_$1$MSG_COLOR"; }
blue()   { printf "$_blue_$1$MSG_COLOR"; }
purple() { printf "$_purple_$1$MSG_COLOR"; }
cyan()   { printf "$_cyan_$1$MSG_COLOR"; }
white()  { printf "$_white_$1$MSG_COLOR"; }

# If $answer is "y", then we don't bother with user input
ask() { 
  if [[ "$answer" == "y" ]]; then return 0; fi
  printf "$MSG_PROMPT$MSG_COLOR$1$_reset_";
  read -p " y/[n] " -n 1 -r
  echo
  [[ $REPLY =~ ^[Yy]$ ]]
  if [ ! $? -ne 0 ]; then return 0; else return 1; fi
}

pause() {
  echo -n "Press y to continue: "
  local continue=""
  while [[ "$continue" != "y" ]]; do 
    read -n 1 continue; 
  done
  echo
}

# https://github.com/the0neWhoKnocks/shell-menu-select
CHAR__GREEN='\033[0;32m'
CHAR__RED='\033[0;31m'
CHAR__RESET='\033[0m'
menuStr=""
returnOrExit=""

function __hideCursor {
  printf "\033[?25l"
  
  # capture CTRL+C so cursor can be reset
  trap "__showCursor && echo '' && ${returnOrExit} 0" SIGINT
}

function __showCursor {
  printf "\033[?25h"
  trap - SIGINT
}

function __clearLastMenu {
  local msgLineCount=$(printf "$menuStr" | wc -l)
  # moves the cursor up N lines so the output overwrites it
  echo -en "\033[${msgLineCount}A"

  # clear to end of screen to ensure there's no text left behind from previous input
  [ $1 ] && tput ed
}

function __renderMenu {
  local start=0
  local selector=""
  local instruction="$1"
  local selectedIndex=$2
  local listLength=$itemsLength
  local longest=0
  local spaces=""
  menuStr="\n $instruction\n"

  # Get the longest item from the list so that we know how many spaces to add
  # to ensure there's no overlap from longer items when a list is scrolling up or down.
  for (( i=0; i<$itemsLength; i++ )); do
    if (( ${#menuItems[i]} > longest )); then
      longest=${#menuItems[i]}
    fi
  done
  spaces=$(printf ' %.0s' $(eval "echo {1.."$(($longest))"}"))

  if [ $3 -ne 0 ]; then
    listLength=$3

    if [ $selectedIndex -ge $listLength ]; then
      start=$(($selectedIndex+1-$listLength))
      listLength=$(($selectedIndex+1))
    fi
  fi

  for (( i=$start; i<$listLength; i++ )); do
    local currItem="${menuItems[i]}"
    currItemLength=${#currItem}

    if [[ $i = $selectedIndex ]]; then
      currentSelection="${currItem}"
      selector="${CHAR__GREEN}ᐅ${CHAR__RESET}"
      currItem="${CHAR__GREEN}${currItem}${CHAR__RESET}"
    else
      selector=" "
    fi

    currItem="${spaces:0:0}${currItem}${spaces:currItemLength}"

    menuStr="${menuStr}\n ${selector} ${currItem}"
  done

  menuStr="${menuStr}\n"

  # whether or not to overwrite the previous menu output
  [ $4 ] && __clearLastMenu

  printf "${menuStr}"
}

function __renderHelp {
  echo;
  echo "Usage: choose [OPTION]..."
  echo "Renders a keyboard navigable menu with a visual indicator of what's selected."
  echo;
  echo "  -h, --help               Displays this message"
  echo "  -i, --index              The initially selected index for the options"
  echo "  -m, --max                Limit how many options are displayed"
  echo "  -o, --options            An Array of options for a user to choose from"
  echo "  -q, --query              Question or statement presented to the user"
  echo "  -v, --selectionVariable  Variable the selected choice will be saved to. Defaults to the 'selectedChoice' variable."
  echo;
  echo "Example:"
  echo "  foodOptions=(\"pizza\" \"burgers\" \"chinese\" \"sushi\" \"thai\" \"italian\" \"shit\")"
  echo;
  echo "  choose -q \"What do you feel like eating?\" -o foodOptions -i 6 -m 4 -v \"firstChoice\""
  echo "  printf \"\\n First choice is '\${firstChoice}'\\n\""
  echo;
  echo "  choose -q \"Select another option in case the first isn't available\" -o foodOptions"
  echo "  printf \"\\n Second choice is '\${selectedChoice}'\\n\""
  echo;
}

function choose {
  local KEY__ARROW_UP=$(echo -e "\033[A")
  local KEY__ARROW_DOWN=$(echo -e "\033[B")
  local KEY__ENTER=$(echo -e "\n")
  local captureInput=true
  local displayHelp=false
  local maxViewable=0
  local instruction="Select an item from the list:"
  local selectedIndex=0
  
  unset selectedChoice
  unset selectionVariable
  
  if [[ "${PS1}" == "" ]]; then
    # running via script
    returnOrExit="exit"
  else
    # running via CLI
    returnOrExit="return"
  fi
  
  if [[ "${BASH}" == "" ]]; then
    printf "\n ${CHAR__RED}[ERROR] This function utilizes Bash expansion, but your current shell is \"${SHELL}\"${CHAR__RESET}\n"
    $returnOrExit 1
  elif [[ $# == 0 ]]; then
    printf "\n ${CHAR__RED}[ERROR] No arguments provided${CHAR__RESET}\n"
    __renderHelp
    $returnOrExit 1
  fi
  
  local remainingArgs=()
  while [[ $# -gt 0 ]]; do
    local key="$1"

    case $key in
      -h|--help)
        displayHelp=true
        shift
        ;;
      -i|--index)
        selectedIndex=$2
        shift 2
        ;;
      -m|--max)
        maxViewable=$2
        shift 2
        ;;
      -o|--options)
        menuItems=$2[@]
        menuItems=("${!menuItems}")
        shift 2
        ;;
      -q|--query)
        instruction="$2"
        shift 2
        ;;
      -v|--selectionVariable)
        selectionVariable="$2"
        shift 2
        ;;
      *)
        remainingArgs+=("$1")
        shift
        ;;
    esac
  done

  # just display help
  if $displayHelp; then
    __renderHelp
    $returnOrExit 0
  fi

  set -- "${remainingArgs[@]}"
  local itemsLength=${#menuItems[@]}
  
  # no menu items, at least 1 required
  if [[ $itemsLength -lt 1 ]]; then
    printf "\n ${CHAR__RED}[ERROR] No menu items provided${CHAR__RESET}\n"
    __renderHelp
    $returnOrExit 1
  fi

  __renderMenu "$instruction" $selectedIndex $maxViewable
  __hideCursor

  while $captureInput; do
    read -rsn3 key # `3` captures the escape (\033'), bracket ([), & type (A) characters.

    case "$key" in
      "$KEY__ARROW_UP")
        selectedIndex=$((selectedIndex-1))
        (( $selectedIndex < 0 )) && selectedIndex=$((itemsLength-1))

        __renderMenu "$instruction" $selectedIndex $maxViewable true
        ;;

      "$KEY__ARROW_DOWN")
        selectedIndex=$((selectedIndex+1))
        (( $selectedIndex == $itemsLength )) && selectedIndex=0

        __renderMenu "$instruction" $selectedIndex $maxViewable true
        ;;

      "$KEY__ENTER")
        __clearLastMenu true
        __showCursor
        captureInput=false
        
        if [[ "${selectionVariable}" != "" ]]; then
          printf -v "${selectionVariable}" "${currentSelection}"
        else
          selectedChoice="${currentSelection}"
        fi
        ;;
    esac
  done
}

# /end of helper functions
# ------------------------

# DO IT
# -----
secrets $@
